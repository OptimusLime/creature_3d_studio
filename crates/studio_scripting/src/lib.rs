//! Lua scripting and ImGui integration for Creature 3D Studio.
//!
//! This crate provides:
//! - Lua VM management with hot reload support
//! - ImGui facade exposed to Lua (`imgui.*` functions)
//! - Scene command interface for Lua (`scene.*` functions)
//! - File watching for live script updates
//!
//! # Thread-Local Pointer Pattern
//!
//! `imgui::Ui` has a frame-scoped lifetime that can't be stored. We use thread-local
//! pointers (`CURRENT_UI`, `CURRENT_COMMANDS`) that are set only during the Lua
//! `on_draw()` callback and cleared immediately after. This allows Lua functions
//! to access frame-specific resources safely.
//!
//! # Safety Invariant
//!
//! The thread-local pointers are only non-null during `on_draw()` execution.
//! All `with_ui()` and `with_commands()` calls check for null and return errors
//! if called outside the valid window.

use bevy::prelude::*;
use bevy_mod_imgui::prelude::{Condition, ImguiContext, Ui};
use mlua::{Function, Lua, Result as LuaResult};
use notify::{recommended_watcher, Event, RecommendedWatcher, RecursiveMode, Watcher};
use rand::Rng;
use std::cell::Cell;
use std::path::Path;
use std::sync::mpsc::{channel, Receiver};
use studio_core::voxel::VoxelWorld;
use studio_physics::{CommandQueue, PhysicsState};

const SCRIPT_PATH: &str = "assets/scripts/ui/main.lua";

/// Resource holding a VoxelWorld generated by MarkovJunior or other Lua scripts.
/// This is set by `scene.set_voxel_world()` and can be read by rendering systems.
#[derive(Resource, Default)]
pub struct GeneratedVoxelWorld {
    /// The voxel world data, if any has been generated.
    pub world: Option<VoxelWorld>,
    /// Whether the world has been updated since last render.
    pub dirty: bool,
}

// Thread-local pointers to frame-scoped resources.
// Only valid during on_draw callback execution.
thread_local! {
    static CURRENT_UI: Cell<*const Ui> = const { Cell::new(std::ptr::null()) };
    static CURRENT_COMMANDS: Cell<*mut CommandQueue> = const { Cell::new(std::ptr::null_mut()) };
    static CURRENT_VOXEL_WORLD: Cell<*mut GeneratedVoxelWorld> = const { Cell::new(std::ptr::null_mut()) };
}

/// Execute a closure with access to the current imgui::Ui.
/// Returns an error if called outside of a UI frame (i.e., not during on_draw).
fn with_ui<R>(f: impl FnOnce(&Ui) -> R) -> LuaResult<R> {
    CURRENT_UI.with(|cell| {
        let ptr = cell.get();
        if ptr.is_null() {
            return Err(mlua::Error::RuntimeError(
                "imgui.* called outside UI frame".into(),
            ));
        }
        // SAFETY: Pointer is only non-null during on_draw callback.
        // Cleared immediately after callback returns.
        Ok(f(unsafe { &*ptr }))
    })
}

/// Execute a closure with mutable access to the command queue.
/// Returns an error if called outside of a UI frame.
fn with_commands<R>(f: impl FnOnce(&mut CommandQueue) -> R) -> LuaResult<R> {
    CURRENT_COMMANDS.with(|cell| {
        let ptr = cell.get();
        if ptr.is_null() {
            return Err(mlua::Error::RuntimeError(
                "scene.* called outside UI frame".into(),
            ));
        }
        // SAFETY: Same invariant as CURRENT_UI.
        Ok(f(unsafe { &mut *ptr }))
    })
}

/// Execute a closure with mutable access to the generated voxel world resource.
/// Returns an error if called outside of a UI frame.
fn with_voxel_world<R>(f: impl FnOnce(&mut GeneratedVoxelWorld) -> R) -> LuaResult<R> {
    CURRENT_VOXEL_WORLD.with(|cell| {
        let ptr = cell.get();
        if ptr.is_null() {
            return Err(mlua::Error::RuntimeError(
                "scene.set_voxel_world called outside UI frame".into(),
            ));
        }
        // SAFETY: Same invariant as CURRENT_UI.
        Ok(f(unsafe { &mut *ptr }))
    })
}

pub struct ScriptingPlugin;

impl Plugin for ScriptingPlugin {
    fn build(&self, app: &mut App) {
        app.add_plugins(bevy_mod_imgui::ImguiPlugin::default())
            .init_resource::<GeneratedVoxelWorld>()
            .add_systems(Startup, (init_scripting, setup_file_watcher))
            .add_systems(Update, (check_hot_reload, render_ui).chain());
    }
}

/// Holds file watcher and change notification receiver
struct ScriptWatcher {
    _watcher: RecommendedWatcher,
    receiver: Receiver<Result<Event, notify::Error>>,
}

fn setup_file_watcher(world: &mut World) {
    let (tx, rx) = channel();

    let mut watcher = match recommended_watcher(move |res| {
        let _ = tx.send(res);
    }) {
        Ok(w) => w,
        Err(e) => {
            error!("Failed to create file watcher: {:?}", e);
            return;
        }
    };

    // Watch the scripts directory
    if let Err(e) = watcher.watch(Path::new("assets/scripts"), RecursiveMode::Recursive) {
        error!("Failed to watch scripts directory: {:?}", e);
        return;
    }

    info!("Hot reload enabled for {}", SCRIPT_PATH);

    world.insert_non_send_resource(ScriptWatcher {
        _watcher: watcher,
        receiver: rx,
    });
}

fn check_hot_reload(watcher: Option<NonSend<ScriptWatcher>>, mut vm: Option<NonSendMut<LuaVm>>) {
    let Some(watcher) = watcher else { return };
    let Some(ref mut vm) = vm else { return };

    // Check for file change events (non-blocking)
    let mut should_reload = false;
    while let Ok(event) = watcher.receiver.try_recv() {
        if let Ok(event) = event {
            // Check if any modified path is our script
            for path in &event.paths {
                if path.ends_with("main.lua") {
                    should_reload = true;
                }
            }
        }
    }

    if should_reload {
        info!("Reloading Lua script...");
        reload_lua_vm(vm);
    }
}

fn reload_lua_vm(vm: &mut LuaVm) {
    // Create fresh Lua VM
    let lua = Lua::new();

    if let Err(e) = register_lua_api(&lua) {
        vm.last_error = Some(format!("Failed to register API: {:?}", e));
        error!("Hot reload failed: {:?}", e);
        return;
    }

    vm.lua = lua;
    vm.draw_fn = None;

    // Reload the script
    if let Err(e) = load_ui_script(vm, SCRIPT_PATH) {
        vm.last_error = Some(format!("{:?}", e));
        error!("Hot reload failed: {:?}", e);
    } else {
        vm.last_error = None;
        info!("Hot reload successful");
    }
}

/// Holds the Lua VM and script state (non-send because Lua is !Send)
struct LuaVm {
    lua: Lua,
    draw_fn: Option<mlua::RegistryKey>,
    last_error: Option<String>,
}

fn init_scripting(world: &mut World) {
    let lua = Lua::new();

    // Register tools.print
    if let Err(e) = register_lua_api(&lua) {
        error!("Failed to register Lua API: {:?}", e);
    }

    let mut vm = LuaVm {
        lua,
        draw_fn: None,
        last_error: None,
    };

    // Load the main UI script
    if let Err(e) = load_ui_script(&mut vm, SCRIPT_PATH) {
        vm.last_error = Some(format!("{:?}", e));
        error!("Failed to load Lua script: {:?}", e);
    }

    world.insert_non_send_resource(vm);
}

fn register_lua_api(lua: &Lua) -> LuaResult<()> {
    let globals = lua.globals();

    // Create scene namespace for scene manipulation
    let scene = lua.create_table()?;

    // scene.print(msg) - log message to console
    scene.set(
        "print",
        lua.create_function(|_, msg: String| {
            info!("[lua] {}", msg);
            Ok(())
        })?,
    )?;

    // scene.spawn_cube(x, y, z) - spawn physics cube at position
    scene.set(
        "spawn_cube",
        lua.create_function(|_, (x, y, z): (f32, f32, f32)| {
            with_commands(|cmds| cmds.spawn_cube(Vec3::new(x, y, z)))?;
            Ok(())
        })?,
    )?;

    // scene.clear() - remove all dynamic bodies
    scene.set(
        "clear",
        lua.create_function(|_, ()| {
            with_commands(|cmds| cmds.clear())?;
            Ok(())
        })?,
    )?;

    // scene.set_voxel_world(world) - set the generated voxel world for rendering
    // Accepts MjLuaVoxelWorld from grid:to_voxel_world()
    scene.set(
        "set_voxel_world",
        lua.create_function(|_, userdata: mlua::AnyUserData| {
            // Extract the MjLuaVoxelWorld userdata and take ownership
            let world: studio_core::markov_junior::MjLuaVoxelWorld = userdata.take()?;
            let inner_world = world.into_inner();
            let voxel_count = inner_world.total_voxel_count();
            with_voxel_world(|res| {
                res.world = Some(inner_world);
                res.dirty = true;
            })?;
            info!("[lua] Set voxel world with {} voxels", voxel_count);
            Ok(())
        })?,
    )?;

    globals.set("scene", scene)?;

    // Create imgui table with UI functions
    let imgui_table = lua.create_table()?;

    // imgui.text(str) - display text
    imgui_table.set(
        "text",
        lua.create_function(|_, text: String| {
            with_ui(|ui| ui.text(&text))?;
            Ok(())
        })?,
    )?;

    // imgui.button(label) -> bool - display button, returns true if clicked
    imgui_table.set(
        "button",
        lua.create_function(|_, label: String| with_ui(|ui| ui.button(&label)))?,
    )?;

    // imgui.window(title, fn) - create a window and call fn inside it
    // Position offset from Scene window so they don't overlap
    imgui_table.set(
        "window",
        lua.create_function(|_, (title, callback): (String, Function)| {
            with_ui(|ui| {
                ui.window(&title)
                    .position([340.0, 40.0], Condition::FirstUseEver)
                    .size([300.0, 200.0], Condition::FirstUseEver)
                    .build(|| {
                        // Call the Lua callback inside the window context
                        if let Err(e) = callback.call::<()>(()) {
                            ui.text_colored([1.0, 0.3, 0.3, 1.0], format!("Error: {:?}", e));
                        }
                    });
            })?;
            Ok(())
        })?,
    )?;

    // imgui.separator() - draw a horizontal separator
    imgui_table.set(
        "separator",
        lua.create_function(|_, ()| {
            with_ui(|ui| ui.separator())?;
            Ok(())
        })?,
    )?;

    // imgui.same_line() - next widget on same line
    imgui_table.set(
        "same_line",
        lua.create_function(|_, ()| {
            with_ui(|ui| ui.same_line())?;
            Ok(())
        })?,
    )?;

    globals.set("imgui", imgui_table)?;

    // mj.* - MarkovJunior procedural generation
    studio_core::markov_junior::register_markov_junior_api(lua)?;

    Ok(())
}

fn load_ui_script(vm: &mut LuaVm, path: &str) -> LuaResult<()> {
    let src = std::fs::read_to_string(path)
        .map_err(|e| mlua::Error::RuntimeError(format!("Failed to read {}: {}", path, e)))?;

    // Execute the script (which should define on_draw function)
    vm.lua.load(&src).set_name(path).exec()?;

    // Get the on_draw function if it exists
    let globals = vm.lua.globals();
    if let Ok(draw_fn) = globals.get::<Function>("on_draw") {
        let key = vm.lua.create_registry_value(draw_fn)?;
        vm.draw_fn = Some(key);
    }

    Ok(())
}

/// Main UI rendering system. Renders Rust UI and invokes Lua on_draw callback.
fn render_ui(
    mut context: NonSendMut<ImguiContext>,
    physics: Res<PhysicsState>,
    mut commands: ResMut<CommandQueue>,
    mut voxel_world: ResMut<GeneratedVoxelWorld>,
    mut vm: Option<NonSendMut<LuaVm>>,
) {
    let ui = context.ui();

    // Enable docking
    ui.dockspace_over_main_viewport();

    // Scene control window (Rust-side) - positioned at top-left
    ui.window("Scene")
        .position([20.0, 40.0], Condition::FirstUseEver)
        .size([300.0, 150.0], Condition::FirstUseEver)
        .build(|| {
            ui.text(format!("Dynamic bodies: {}", physics.dynamic_body_count()));
            ui.separator();

            if ui.button("Spawn Cube") {
                let mut rng = rand::thread_rng();
                let x = rng.gen_range(-3.0..3.0);
                let z = rng.gen_range(-3.0..3.0);
                let y = rng.gen_range(3.0..8.0);
                commands.spawn_cube(Vec3::new(x, y, z));
            }

            ui.same_line();

            if ui.button("Clear All") {
                commands.clear();
            }
        });

    // Call Lua on_draw with frame-scoped pointers set
    if let Some(ref mut vm) = vm {
        if let Some(ref key) = vm.draw_fn {
            // Set pointers for the duration of the Lua callback
            CURRENT_UI.with(|cell| cell.set(ui as *const Ui));
            CURRENT_COMMANDS.with(|cell| cell.set(commands.as_mut() as *mut CommandQueue));
            CURRENT_VOXEL_WORLD
                .with(|cell| cell.set(voxel_world.as_mut() as *mut GeneratedVoxelWorld));

            let result: LuaResult<()> = (|| {
                let draw_fn: Function = vm.lua.registry_value(key)?;
                draw_fn.call::<()>(())?;
                Ok(())
            })();

            // Clear pointers immediately after callback returns
            CURRENT_UI.with(|cell| cell.set(std::ptr::null()));
            CURRENT_COMMANDS.with(|cell| cell.set(std::ptr::null_mut()));
            CURRENT_VOXEL_WORLD.with(|cell| cell.set(std::ptr::null_mut()));

            if let Err(e) = result {
                vm.last_error = Some(format!("{:?}", e));
            } else {
                vm.last_error = None;
            }
        }

        // Show Lua errors if any
        if let Some(ref err) = vm.last_error {
            ui.window("Lua Error")
                .size([400.0, 150.0], Condition::FirstUseEver)
                .build(|| {
                    ui.text_wrapped(err);
                });
        }
    }
}
