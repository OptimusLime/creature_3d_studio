# Alternative Sky Approach: Layered MarkovJunior Textures + UV Flow

**Status:** ACTIVE PLAN - This is the direction we're pursuing.

**Core Philosophy:** A **layered texture approach** where ALL sky elements (clouds, moons, stars) are generated by MarkovJunior, creating a unified stylized aesthetic.

**Related Documents:**
- `docs/plans/markov_sky_textures_research.md` - MJ model approaches for clouds, moons, stars
- `docs/plans/moon_environment_lighting.md` - Moon-position-based terrain lighting (NEW)

---

## Current Progress

**COMPLETED:**
- Phase 0-4: Test harness, cloud textures, moon textures on dome
- Phase 4.1: Fixed sky dome world-space sampling
- Phase 8-9: Moon texture generation, moon layer rendering
- Phase 10-11: Moon orbital movement, dual moons

**IN PROGRESS:**
- Moon glow/bloom refinement (tight radius, no cloud bleed)
- Moon crater texture quality (needs circles-in-circles approach)

**NEXT UP (Environment Lighting - See `moon_environment_lighting.md`):**
- Phase A: Fix deferred_lighting to use dynamic moon uniforms
- Phase B: Moon altitude-based intensity scaling
- Phase C: Zenith-darkness (both moons below = very dark)
- Phase D: Dynamic ambient from moon colors

---

## Inspiration

**Source:** GDC Vault - The Last of Us Sky Rendering

Their technique:
1. Use a **painted sky texture** (not fully procedural)
2. Apply **UV flow distortion** to create movement
3. Map onto a **sky dome** surrounding the camera
4. Flow direction derived from wind in tangent space:
   - Vertical flow = `dot(wind_direction, binormal)`
   - Horizontal flow = `dot(wind_direction, tangent)`

**Why this is interesting for us:**
- We have **MarkovJunior** - a powerful procedural texture generator
- We can create **stylized, seeded cloud patterns** that match our aesthetic
- UV flow animation is **cheap and elegant**
- Dome geometry avoids all our current view direction reconstruction issues

---

## Execution Plan (Verification-First Design)

**Principle:** Each phase ends with trivial verification. If verification is hard, the phase is wrong. Test harnesses are built BEFORE the features that need them.

---

### Phase 0: Test Harness Setup

**Outcome:** A test example that captures screenshots automatically, so all future phases can be verified by running one command.

**Verification:** 
```bash
cargo run --example p32_markov_sky_test
ls screenshots/markov_sky/
# Shows: frame_0001.png exists
```

**Tasks:**

1. Create `examples/p32_markov_sky_test.rs`:
   - Based on existing `p31_visual_fidelity_test.rs` pattern
   - Uses `VoxelWorldApp` for scene setup (existing helper)
   - Uses Bevy's `Screenshot::primary_window()` + `save_to_disk()` (same as p31)
   - Captures screenshot to `screenshots/markov_sky/frame_XXXX.png`
   - Auto-exits after capture
   - File: `examples/p32_markov_sky_test.rs`

2. Create output directory structure:
   - `screenshots/markov_sky/` for frame output
   - Already gitignored via existing `screenshots/` pattern

3. Verify harness works:
   - Run example, confirm PNG appears
   - PNG shows existing sky dome (purple gradient from current `sky_dome.wgsl`)

**Existing Code Used:**
- `VoxelWorldApp` from `studio_core` for scene setup
- `bevy::render::view::screenshot::{save_to_disk, Screenshot}` for capture
- Pattern from `examples/p31_visual_fidelity_test.rs`
- Existing `SkyDomeConfig` and deferred pipeline

**Why Phase 0 First:** All future phases need screenshot verification. Building the harness first means every subsequent phase has trivial verification: run command, look at PNG.

---

### Phase 1: Verify Existing Sky Dome Works

**Outcome:** Confirm existing sky dome renders and we can see it in the test harness. This is our baseline.

**Verification:**
```bash
cargo run --example p32_markov_sky_test
# Open screenshots/markov_sky/frame_0001.png
# Should show: Existing sky gradient (purple/dark from current sky_dome.wgsl)
```

**Tasks:**

1. Ensure test example has sky dome enabled:
   - `SkyDomeConfig { enabled: true, .. }` in test setup
   - Camera pointed at sky (not just terrain)

2. Capture baseline screenshot:
   - Verify existing procedural sky renders
   - This proves the deferred pipeline and sky dome node work

3. Document baseline:
   - What does the current sky look like?
   - This is our starting point before adding texture layers

**Existing Code Used:**
- `crates/studio_core/src/deferred/sky_dome.rs` - SkyDomeConfig
- `crates/studio_core/src/deferred/sky_dome_node.rs` - render graph node
- `assets/shaders/sky_dome.wgsl` - current procedural sky shader

**Why Verify First:** We already have a sky dome. Before adding complexity, verify it works in our new test harness. If it doesn't render, we fix that first.

---

### Phase 2: Add Cloud Texture Layer to Existing Sky

**Outcome:** A cloud texture (placeholder) composites on top of the existing sky gradient. This extends the current shader, not replaces it.

**Verification:**
```bash
cargo run --example p32_markov_sky_test
# Open screenshots/markov_sky/frame_0001.png
# Should show: Cloud pattern overlaid on existing sky gradient
```

**Tasks:**

1. Create placeholder cloud texture:
   - Simple 256x256 PNG with visible pattern (checkerboard or noise)
   - Place at `assets/textures/clouds_placeholder.png`
   - Must be obvious pattern so we can see if texture sampling works

2. Extend existing sky_dome.wgsl:
   - Add texture sampler binding for cloud texture
   - Add cloud UV computation in `compute_sky_color()`
   - Alpha-blend cloud layer over existing gradient
   - Keep all existing code (gradient, moons, stars)

3. Extend SkyDomeUniform in sky_dome_node.rs:
   - Add cloud texture handle
   - Add cloud texture binding to pipeline

4. Verify: Run test, placeholder pattern visible over sky gradient

**Existing Code Modified:**
- `assets/shaders/sky_dome.wgsl` - add cloud sampling
- `crates/studio_core/src/deferred/sky_dome_node.rs` - add texture binding
- `crates/studio_core/src/deferred/sky_dome.rs` - add cloud texture config

**Why Extend Not Replace:** The existing sky dome has working gradient, view direction, uniform passing. We ADD cloud layer, not rebuild from scratch.

---

### Phase 3: MarkovJunior Cloud Texture Generation

**Outcome:** MarkovJunior generates a cloud texture PNG that we can visually inspect.

**Verification:**
```bash
cargo run --example p33_mj_cloud_gen
ls assets/textures/generated/
# Shows: mj_clouds_001.png exists
# Open PNG in image viewer - shows cloud-like pattern
```

**Tasks:**

1. Create MarkovJunior cloud model:
   - File: `MarkovJunior/models/CloudTexture.xml`
   - 2D model, 256x256 output
   - Simple blob growth pattern (can improve later)
   - Must be tileable (use appropriate boundary conditions)

2. Create generation example:
   - File: `examples/p33_mj_cloud_gen.rs`
   - Loads `CloudTexture.xml`
   - Runs to completion
   - Uses **existing** `render_2d()` and `save_png()` from `studio_core::markov_junior::render`
   - Exports result as PNG to `assets/textures/generated/mj_clouds_001.png`

3. Create output directory:
   - `assets/textures/generated/` (add to .gitignore if generated at runtime, or commit if pre-baked)

4. Verify: Run generation, open PNG, see cloud pattern

**Existing Code Used:**
- `crates/studio_core/src/markov_junior/render.rs` already has `render_2d()` and `save_png()`
- `Model::load_with_size()` for loading XML
- `RenderPalette::from_palette_xml()` for color mapping

**Why Separate Generation:** Isolates MJ texture generation from rendering pipeline. If PNG looks wrong, we iterate on MJ model. If PNG looks good but rendering is wrong, we debug the shader.

---

### Phase 4: MJ Clouds on Dome (Static)

**Outcome:** MarkovJunior-generated cloud texture displays on the sky dome instead of placeholder.

**Verification:**
```bash
cargo run --example p33_mj_cloud_gen  # Generate texture first
cargo run --example p34_sky_terrain_test -- --test
# Open screenshots/sky_terrain/terrain_sky_test.png
# Should show: MJ cloud pattern on dome, clouds stay FIXED when camera rotates
```

**Tasks:**

1. Update SkyDomeConfig to point to MJ texture:
   - Change cloud texture path from `clouds_placeholder.png` to `generated/mj_clouds_001.png`
   - Or add config option to specify cloud texture path

2. Verify: MJ clouds visible on dome (different from placeholder)

**Why This Phase:** Connects the MJ pipeline to the rendering pipeline. Trivial change but proves end-to-end MJ→shader works.

---

### Phase 4.1: Fix Sky Dome - TWO OPTIONS

**Problem:** Current sky dome is a fullscreen shader pass using screen-space UV. This causes:
- Clouds move when camera rotates (WRONG - should stay fixed in world)
- Clouds change when camera zooms (WRONG - zoom shouldn't affect sky appearance)
- No proper world-space sampling

---

#### OPTION A: Actual Sphere Mesh (RECOMMENDED - SIMPLER)

**Approach:** Spawn a large sphere mesh in Bevy, apply cloud texture as material, let Bevy handle UV mapping.

**Why this is better:**
- Bevy handles all the view/projection math
- Standard UV mapping on sphere - no manual reconstruction
- Can use standard PBR or unlit material
- Sphere follows camera position (translate only, no rotation)
- Clouds stay fixed because sphere doesn't rotate

**Implementation:**
```rust
// Spawn sky sphere centered on camera
commands.spawn((
    Mesh3d(meshes.add(Sphere::new(500.0).mesh().uv(64, 64))),
    MeshMaterial3d(sky_material),
    Transform::from_translation(camera_pos),
    SkyDome, // marker component
));

// System to follow camera position (not rotation)
fn sky_follow_camera(
    camera: Query<&Transform, With<Camera>>,
    mut sky: Query<&mut Transform, (With<SkyDome>, Without<Camera>)>,
) {
    let cam_pos = camera.single().translation;
    for mut sky_transform in &mut sky {
        sky_transform.translation = cam_pos; // position only, no rotation
    }
}
```

**Pros:**
- Simple, standard Bevy patterns
- No custom shader math for view direction
- Easy to debug (it's just a mesh)
- Can render sky gradient as separate inner sphere

**Cons:**
- Two render passes (sphere + deferred scene)
- Need to handle render order (sky behind everything)

---

#### OPTION B: Fix Fullscreen Shader (Current Approach)

**Approach:** Keep fullscreen pass, fix the inv_view_proj reconstruction math.

**Why this might be needed:**
- Already integrated with deferred pipeline
- Single pass
- More control over blending with scene

**Implementation:** (as currently documented below)

**Verification:**
```bash
cargo run --example p34_sky_terrain_test
# Rotate with A/D - clouds should stay FIXED in world space
# Zoom with Q/E - clouds should NOT change appearance
# Tilt with Up/Down - should see different parts of the sky
```

**Tasks:**

1. **Verify inv_view_proj is passed correctly to shader:**
   - In `sky_dome_node.rs`, check `inv_view_proj` computation
   - Add debug: output `inv_view_proj[0][0]` as color to verify it's not identity
   - File: `crates/studio_core/src/deferred/sky_dome_node.rs`

2. **Fix view direction reconstruction in shader:**
   - Convert screen UV to NDC: `ndc = vec4(uv.x * 2 - 1, (1 - uv.y) * 2 - 1, 1, 1)`
   - Multiply by inv_view_proj: `world_pos = inv_view_proj * ndc`
   - Normalize: `view_dir = normalize(world_pos.xyz / world_pos.w)`
   - File: `assets/shaders/sky_dome.wgsl`

3. **Convert view direction to spherical UV for cloud sampling:**
   - `yaw = atan2(view_dir.x, view_dir.z)` → horizontal angle
   - `pitch = asin(view_dir.y)` → vertical angle
   - Map to UV: `cloud_uv = vec2((yaw / PI + 1) * 0.5, 0.5 - pitch / PI)`
   - File: `assets/shaders/sky_dome.wgsl`

4. **Keep gradient as screen-space (intentional):**
   - The horizon-to-zenith gradient SHOULD use screen UV
   - Only clouds need world-space sampling

5. **Test systematically:**
   - First: Output view_dir as RGB color (x→R, z→B, y→G)
   - Verify: Rotating camera changes the colors correctly
   - Then: Add spherical UV conversion
   - Verify: Cloud pattern stays fixed when rotating

**Debugging Steps (Hypothesis-Driven):**

If clouds still move with camera:
1. **Hypothesis:** inv_view_proj is wrong
   - **Test:** Output `inv_view_proj[0][0]` as brightness
   - **Expected:** Changes when camera moves

2. **Hypothesis:** NDC reconstruction is wrong
   - **Test:** Output reconstructed view_dir as RGB
   - **Expected:** R=left/right, G=up/down, B=forward/back

3. **Hypothesis:** Spherical conversion is wrong
   - **Test:** Output yaw and pitch as UV directly
   - **Expected:** Smooth gradient across screen

**Why This Matters:** The whole layered texture approach depends on stable world-space sampling. Without this fix, nothing else works correctly.

---

### Phase 4.2: Fix Character Controller

**Problem:** Character controller has multiple issues:
- Camera may be in front instead of behind player
- Player yaw stored separately AND applied to transform (double rotation)

**Correct Design:**
- Character has Transform with position and rotation
- A/D changes character's Transform.rotation (yaw)
- W/S moves forward/backward relative to character's facing direction
- Camera follows BEHIND character, uses character's Transform.rotation
- Camera has its own pitch (Up/Down arrows)
- Camera has adjustable distance (Q/E)

**Verification:**
```bash
cargo run --example p34_sky_terrain_test
# W - moves AWAY from camera (forward)
# S - moves TOWARD camera (backward)  
# A/D - rotates player, camera follows behind
# Up/Down - tilts camera view
# Q/E - zooms camera in/out
```

**Tasks:**

1. **Character stores yaw, physics applies to Transform:**
   - `PlayerCharacter.yaw` stores facing direction
   - Physics system sets `transform.rotation = Quat::from_rotation_y(yaw)`
   - Movement uses yaw for forward direction
   - File: `crates/studio_core/src/character_controller.rs`

2. **Camera follows behind character's Transform:**
   - Get forward direction from `player_transform.rotation * Vec3::NEG_Z`
   - Camera offset is BEHIND player: `player_transform.rotation * Vec3::Z * distance`
   - Add pitch offset for vertical tilt
   - File: `crates/studio_core/src/character_controller.rs`

3. **Verify camera is behind, not in front:**
   - When pressing W, player should move AWAY from camera
   - Camera should be looking at player's back

---

### Phase 5: UV Flow Animation

**Outcome:** Clouds animate (scroll) across the dome based on time.

**Verification:**
```bash
cargo run --example p32_markov_sky_test -- --frames=60
# Open screenshots/markov_sky/frame_0001.png and frame_0060.png
# Clouds should be at DIFFERENT positions (visible movement)
```

**Tasks:**

1. Add time uniform to shader:
   - `time: f32` in uniform struct
   - Pass elapsed time from Bevy

2. Add flow animation to shader:
   - `animated_uv = uv + vec2(time * 0.1, 0.0)`
   - Simple horizontal scroll first

3. Update test to capture multiple frames:
   - Add `--frames=N` argument
   - Capture N frames with incrementing numbers
   - Small delay between frames

4. Verify: Compare first and last frame, clouds moved

**Why Simple Scroll First:** Proves time uniform works and UV animation is visible. Complex wind-based flow comes later.

---

### Phase 6: FFMPEG Video Script

**Outcome:** Single command produces MP4 video from captured frames.

**Verification:**
```bash
./scripts/make_sky_video.sh
# Creates: videos/markov_sky_preview.mp4
# Open video - shows animated clouds
```

**Tasks:**

1. Create video script:
   - File: `scripts/make_sky_video.sh`
   - Uses ffmpeg to combine PNGs into MP4
   - `ffmpeg -framerate 30 -i screenshots/markov_sky/frame_%04d.png -c:v libx264 -pix_fmt yuv420p videos/markov_sky_preview.mp4`

2. Create videos directory:
   - `videos/` with `.gitignore` entry

3. Verify: Run script, video plays

**Why Video Script:** Makes reviewing animation trivial. Instead of clicking through 60 PNGs, watch 2-second video.

---

### Phase 7: Wind-Based UV Flow

**Outcome:** UV flow direction comes from wind vector, not hardcoded.

**Verification:**
```bash
cargo run --example p32_markov_sky_test -- --frames=60 --wind=1,0,0
cargo run --example p32_markov_sky_test -- --frames=60 --wind=0,0,1
# Compare videos - clouds should move in DIFFERENT directions
```

**Tasks:**

1. Add wind uniform to shader:
   - `wind_direction: vec3<f32>` in uniform struct

2. Implement tangent-space flow:
   - Add tangent/binormal to vertex attributes
   - Compute `horizontal_flow = dot(wind, tangent)`
   - Compute `vertical_flow = dot(wind, binormal)`
   - `animated_uv = uv + vec2(horizontal_flow, vertical_flow) * time`

3. Add wind CLI argument to test:
   - `--wind=X,Y,Z` sets wind direction

4. Verify: Different wind directions produce different flow

---

### Phase 8: Moon Texture Generation

**Outcome:** MarkovJunior generates a moon texture PNG.

**Verification:**
```bash
cargo run --example p34_mj_moon_gen
ls assets/textures/generated/
# Shows: mj_moon_001.png exists
# Open PNG - shows moon surface pattern (craters, etc.)
```

**Tasks:**

1. Create MarkovJunior moon model:
   - File: `MarkovJunior/models/MoonTexture.xml`
   - Circular boundary (moon shape)
   - Crater pattern or stylized surface

2. Create generation example:
   - File: `examples/p34_mj_moon_gen.rs`
   - Same pattern as p33_mj_cloud_gen
   - Uses existing `render_2d()` and `save_png()` from render.rs
   - Exports to `assets/textures/generated/mj_moon_001.png`

3. Verify: Moon texture PNG exists and looks like a moon

**Existing Code Used:**
- Same as Phase 3: `render_2d()`, `save_png()`, `Model::load_with_size()`

---

### Phase 9: Moon Layer (Static Position)

**Outcome:** Moon texture appears in sky at fixed position, BEHIND the cloud layer.

**Verification:**
```bash
cargo run --example p32_markov_sky_test
# Open screenshot
# Should show: Moon visible in sky (fixed position), clouds in front of moon
```

**Tasks:**

1. Extend sky_dome.wgsl with moon layer:
   - Add second texture sampler for moon texture
   - Add moon position uniform (vec2 in UV space, or vec3 direction)
   - Render moon BEFORE clouds in compositing order
   - Moon is circular disc at specified UV position

2. Extend SkyDomeUniform:
   - Add moon texture binding
   - Add moon position/size uniforms (can reuse existing moon1_direction)

3. Update SkyDomeConfig:
   - Add moon texture path
   - Connect to existing orbital system OR use fixed position for now

4. Verify: Moon visible, clouds layer in front

**Existing Code Used:**
- Current sky_dome.wgsl already has `moon1_direction`, `moon1_color`, `moon1_params` uniforms
- Current sky_dome_node.rs already computes moon positions from MoonOrbit

---

### Phase 10: Moon Orbital Movement

**Outcome:** Moon position changes based on time.

**Verification:**
```bash
cargo run --example p32_markov_sky_test -- --frames=120 --time-speed=10
./scripts/make_sky_video.sh
# Watch video - moon should move across sky
```

**Tasks:**

1. Add moon position uniform:
   - `moon1_position: vec2<f32>` (UV space position)
   - Compute from orbital system

2. Connect to existing MoonOrbit:
   - Convert 3D direction to dome UV position

3. Verify: Moon moves in video

---

### Phase 11: Second Moon

**Outcome:** Two moons in sky, moving independently.

**Verification:**
```bash
cargo run --example p32_markov_sky_test -- --frames=120 --time-speed=10
./scripts/make_sky_video.sh
# Watch video - TWO moons moving at different speeds
```

**Tasks:**

1. Generate second moon texture:
   - Different MJ model for variety
   - `mj_moon_002.png`

2. Add second moon to shader:
   - `moon2_position`, `moon2_texture`

3. Connect to second MoonOrbit (orange moon)

4. Verify: Both moons visible, different orbits

---

### Phase 12: Star Field Texture

**Outcome:** MarkovJunior generates star field, visible behind clouds and moons.

**Verification:**
```bash
cargo run --example p35_mj_stars_gen
# Open assets/textures/generated/mj_stars_001.png - shows star pattern
cargo run --example p32_markov_sky_test
# Screenshot shows stars behind everything
```

**Tasks:**

1. Create MJ star field model:
   - `MarkovJunior/models/StarField.xml`
   - Sparse bright points on dark background

2. Add star layer to shader:
   - Background layer (rendered first)
   - Stars show through cloud gaps

3. Verify: Stars visible in final composite

---

### Phase 13: Moon Light on Clouds

**Outcome:** Clouds near moon are tinted by moon color.

**Verification:**
```bash
cargo run --example p32_markov_sky_test -- --time=0.25
# Screenshot: Clouds near purple moon have purple tint
cargo run --example p32_markov_sky_test -- --time=0.6  
# Screenshot: Clouds near orange moon have orange tint
```

**Tasks:**

1. Add moon lighting calculation:
   - Distance from UV to moon position
   - Tint clouds based on proximity + moon color

2. Verify: Cloud color varies based on moon position

---

## Environment Lighting Phases (NEW)

**See `docs/plans/moon_environment_lighting.md` for full details.**

These phases address the critical issue that **terrain lighting doesn't respond to moon positions**.

### Phase A: Fix Deferred Lighting Uniforms

**Priority:** HIGHEST - Root cause fix

**Problem:** `deferred_lighting.wgsl` uses hardcoded constants instead of dynamic uniforms.

**Outcome:** Terrain lighting changes when moon T/Y keys are pressed.

**Verification:**
```bash
cargo run --example p34_sky_terrain_test
# Press T - terrain lighting shifts with purple moon position
# Press Y - terrain lighting shifts with orange moon position
```

---

### Phase B: Moon Altitude-Based Intensity

**Priority:** HIGH

**Outcome:** Moon light on terrain scales with altitude:
- Horizon (altitude ~0): dim, warm
- Zenith (altitude ~1): full brightness
- Below horizon: no contribution

**Verification:**
```bash
cargo run --example p34_sky_terrain_test
# Moon at horizon = dimmer terrain
# Moon at zenith = brighter terrain
```

---

### Phase C: Zenith-Darkness

**Priority:** HIGH

**Outcome:** When BOTH moons are below horizon, terrain becomes nearly black.

**Verification:**
```bash
cargo run --example p34_sky_terrain_test
# Move both moons below horizon (T/Y past 0.5)
# Terrain should be very dark
```

---

### Phase D: Dynamic Ambient Color

**Priority:** HIGH

**Outcome:** Ambient light color blends between moon colors based on visibility.

**Verification:**
```bash
cargo run --example p34_sky_terrain_test
# Purple moon high - purple ambient tint
# Orange moon high - orange ambient tint
```

---

### Phase E: Dawn/Dusk Horizon Scatter

**Priority:** MEDIUM

**Outcome:** Sky has warm glow toward rising/setting moon.

**Verification:**
```bash
cargo run --example p34_sky_terrain_test
# Moon near horizon - warm glow in sky toward moon
```

---

### Phase F: Environment LUT (Optional)

**Priority:** LOW - Only if procedural isn't flexible enough

**Outcome:** 2D texture maps moon altitudes to environment parameters for artist control.

---

## Integrated Phase Order

| Order | Phase | Priority | Description |
|-------|-------|----------|-------------|
| 1 | **A** | HIGHEST | Fix deferred lighting uniforms |
| 2 | **B** | HIGH | Moon altitude intensity scaling |
| 3 | **C** | HIGH | Zenith-darkness |
| 4 | **D** | HIGH | Dynamic ambient color |
| 5 | 5 | MEDIUM | UV flow animation |
| 6 | **E** | MEDIUM | Dawn/dusk scatter |
| 7 | 7 | MEDIUM | Wind-based flow |
| 8 | 8 | MEDIUM | Moon texture improvement |
| 9 | 12 | LOW | Star field |
| 10 | 13 | MEDIUM | Moon light on clouds |
| 11 | **F** | LOW | Environment LUT (optional) |

---

## Full Pipeline Summary

After all phases:

```
┌──────────────────────────────────────────────────────────┐
│  INPUT                                                   │
│  - MarkovJunior models: CloudTexture.xml, MoonTexture.xml│
│  - Time, wind direction                                  │
├──────────────────────────────────────────────────────────┤
│  GENERATION (offline or startup)                         │
│  - p33_mj_cloud_gen → mj_clouds_001.png                 │
│  - p34_mj_moon_gen → mj_moon_001.png, mj_moon_002.png   │
│  - p35_mj_stars_gen → mj_stars_001.png                  │
├──────────────────────────────────────────────────────────┤
│  RUNTIME RENDERING                                       │
│  - Sky dome mesh with layered shader                    │
│  - UV flow animation for clouds                         │
│  - Moon positions from orbital system                   │
│  - Moon lighting on clouds                              │
├──────────────────────────────────────────────────────────┤
│  OUTPUT                                                  │
│  - Animated sky with flowing clouds                     │
│  - Two moons orbiting independently                     │
│  - Stars visible through cloud gaps                     │
│  - Moon light tinting nearby clouds                     │
└──────────────────────────────────────────────────────────┘
```

---

## The Concept

```
┌─────────────────────────────────────────────────────────┐
│                    OFFLINE / STARTUP                     │
├─────────────────────────────────────────────────────────┤
│  MarkovJunior generates 2D cloud texture                │
│  (tileable, stylized, matches world aesthetic)          │
│                         ↓                               │
│  Export as texture atlas or single tileable image       │
└─────────────────────────────────────────────────────────┘
                          ↓
┌─────────────────────────────────────────────────────────┐
│                      RUNTIME                             │
├─────────────────────────────────────────────────────────┤
│  Sky Dome Mesh (hemisphere)                             │
│  - Follows camera position (doesn't rotate with it)     │
│  - UV mapped to sample cloud texture                    │
│  - UV coordinates distorted by flow vectors             │
│  - Flow = f(wind_direction, time, tangent_space)        │
│                         ↓                               │
│  Result: Clouds appear to drift naturally               │
└─────────────────────────────────────────────────────────┘
```

---

## Why This Solves Our Current Problems

### Problem 1: View Direction Reconstruction
**Current:** We reconstruct view_dir from UV + inv_view_proj matrix. This is fragile.
**Alternative:** Dome mesh provides view direction implicitly. Each vertex's position relative to camera IS the view direction.

### Problem 2: Procedural Complexity
**Current:** Everything computed per-pixel: moons, stars, gradient, clouds, glow.
**Alternative:** Pre-baked cloud texture + simple UV sampling. Much simpler shader.

### Problem 3: Debugging Difficulty
**Current:** Hard to isolate which math is wrong.
**Alternative:** Texture is visible in editor. Flow can be visualized. Each component is separable.

### Problem 4: Aesthetic Consistency
**Current:** Procedural noise doesn't necessarily match MarkovJunior world style.
**Alternative:** Clouds ARE generated by MarkovJunior, matching the procedural aesthetic perfectly.

---

## Architecture: Multi-Layer Texture Stack

The skybox is composed of **multiple texture layers**, each generated by MarkovJunior, stacked and potentially affected by UV flow.

```
┌─────────────────────────────────────────────────────────┐
│  LAYER 4: Star Field (furthest, background)             │
│  - MarkovJunior generated star pattern                  │
│  - Slow rotation or static                              │
│  - Subtle twinkle via noise modulation                  │
├─────────────────────────────────────────────────────────┤
│  LAYER 3: Moon 2 (Orange moon)                          │
│  - MarkovJunior moon texture (craters, rings, etc.)     │
│  - Orbital position from day/night system               │
│  - Emissive, casts light influence                      │
├─────────────────────────────────────────────────────────┤
│  LAYER 2: Moon 1 (Purple moon)                          │
│  - MarkovJunior moon texture                            │
│  - Different style: crushed, scattered, or classic      │
│  - Orbital position independent of moon 2               │
├─────────────────────────────────────────────────────────┤
│  LAYER 1: Cloud Layer (closest to camera)               │
│  - MarkovJunior cloud texture                           │
│  - UV flow animation (wind direction)                   │
│  - Alpha blended, moons show through gaps               │
├─────────────────────────────────────────────────────────┤
│  LAYER 0: Sky Gradient (base)                           │
│  - Solid color gradient or simple texture               │
│  - Zenith to horizon blend                              │
└─────────────────────────────────────────────────────────┘
```

### Layer Details

#### Layer 0: Sky Gradient (Base)
- **Geometry:** Hemisphere or full sphere mesh
- **Position:** Centered on camera, does NOT rotate with camera
- **Shader:** Simple gradient or solid colors
- **Purpose:** Background color (zenith to horizon)

#### Layer 1: Cloud Layer
- **Source:** MarkovJunior generated texture
- **Animation:** UV flow based on wind direction
- **Blending:** Alpha blend, clouds occlude moons partially
- **Purpose:** Animated atmosphere

#### Layer 2 & 3: Moon Layers
- **Source:** MarkovJunior generated moon textures
- **Ideas for moon styles:**
  - Classic cratered moon
  - Crushed/shattered crescent
  - Disassembled fragments orbiting
  - Saturn-style rings (debris field)
  - Glowing arcane patterns
- **Position:** Orbital system places texture on dome
- **Lighting:** Emissive, affects cloud tint, atmospheric scattering

#### Layer 4: Star Field
- **Source:** MarkovJunior generated star pattern
- **Style:** Stylized dots, constellations, nebula wisps
- **Animation:** Optional slow drift, twinkle noise
- **Purpose:** Deep background, visible through cloud gaps

---

## UV Flow Implementation

### The Last of Us Technique

```hlsl
// Per-vertex on dome mesh:
float3 tangent = ...; // Tangent of dome surface (horizontal)
float3 binormal = ...; // Binormal of dome surface (vertical)
float3 wind_dir = normalize(wind_direction);

// Flow components
float horizontal_flow = dot(wind_dir, tangent);
float vertical_flow = dot(wind_dir, binormal);
float2 flow = float2(horizontal_flow, vertical_flow);

// In fragment shader:
float2 animated_uv = base_uv + flow * time * flow_speed;
float4 cloud_color = texture(cloud_texture, animated_uv);
```

### Our Adaptation for WGSL

```wgsl
struct CloudDomeUniforms {
    wind_direction: vec3<f32>,
    flow_speed: f32,
    time: f32,
    cloud_density: f32,
    cloud_tint: vec4<f32>,
}

@vertex
fn vs_main(
    @location(0) position: vec3<f32>,
    @location(1) normal: vec3<f32>,
    @location(2) uv: vec2<f32>,
    @location(3) tangent: vec4<f32>,
) -> VertexOutput {
    var out: VertexOutput;
    
    // Dome follows camera position
    let world_pos = camera_position + position * dome_radius;
    out.clip_position = view_proj * vec4(world_pos, 1.0);
    
    // Compute flow in tangent space
    let T = tangent.xyz;
    let B = cross(normal, T) * tangent.w;
    
    let horizontal_flow = dot(uniforms.wind_direction, T);
    let vertical_flow = dot(uniforms.wind_direction, B);
    out.flow = vec2(horizontal_flow, vertical_flow);
    
    out.uv = uv;
    return out;
}

@fragment
fn fs_main(in: VertexOutput) -> @location(0) vec4<f32> {
    // Animate UV with flow
    let animated_uv = in.uv + in.flow * uniforms.time * uniforms.flow_speed;
    
    // Sample cloud texture (tileable)
    let cloud = textureSample(cloud_texture, cloud_sampler, animated_uv);
    
    // Apply tint and density
    let color = cloud.rgb * uniforms.cloud_tint.rgb;
    let alpha = cloud.a * uniforms.cloud_density;
    
    return vec4(color, alpha);
}
```

---

## MarkovJunior Texture Generation

### Cloud Textures

Use MarkovJunior to generate stylized 2D cloud patterns:

```xml
<!-- clouds.xml - Example MarkovJunior model for cloud generation -->
<sequence>
  <!-- Start with random seeds -->
  <one in="B" out="W" p="0.02"/>
  
  <!-- Grow cloud blobs -->
  <markov>
    <rule in="WB" out="WW" p="0.6"/>
    <rule in="BW" out="WW" p="0.6"/>
  </markov>
  
  <!-- Add wispy edges -->
  <convolution neighborhood="Moore">
    <rule in="WBB/BBB/BBB" out="G"/>  <!-- Edge detection -->
  </convolution>
  
  <!-- Blur/soften -->
  <all in="G" out="W" p="0.5"/>
</sequence>
```

### Moon Textures

Generate stylized moon surfaces:

```xml
<!-- moon_cratered.xml - Classic cratered moon -->
<sequence>
  <!-- Base surface -->
  <all in="B" out="G"/>
  
  <!-- Scatter crater seeds -->
  <one in="G" out="D" p="0.03"/>
  
  <!-- Grow craters with rings -->
  <markov>
    <rule in="DG" out="DR"/>
    <rule in="RG" out="RW"/>
  </markov>
</sequence>
```

```xml
<!-- moon_shattered.xml - Crushed/scattered moon -->
<sequence>
  <!-- Create main body -->
  <one in="B" out="W" p="0.15"/>
  <markov>
    <rule in="WB" out="WW" p="0.4"/>
  </markov>
  
  <!-- Fracture lines -->
  <path from="edge" to="center" color="D"/>
  
  <!-- Scatter debris -->
  <one in="B" out="G" p="0.01"/>
</sequence>
```

```xml
<!-- moon_rings.xml - Saturn-style debris rings -->
<sequence>
  <!-- Central body -->
  <one in="B" out="W" p="0.08" x="center" y="center"/>
  <markov steps="50">
    <rule in="WB" out="WW"/>
  </markov>
  
  <!-- Ring bands at specific radii -->
  <ring center="true" radius="20" width="3" color="G"/>
  <ring center="true" radius="28" width="2" color="G"/>
  
  <!-- Debris scatter in rings -->
  <one in="G" out="R" p="0.3"/>
</sequence>
```

### Star Field Textures

Generate stylized star patterns:

```xml
<!-- stars.xml - Stylized star field -->
<sequence>
  <!-- Sparse bright stars -->
  <one in="B" out="W" p="0.002"/>
  
  <!-- Medium density dimmer stars -->
  <one in="B" out="G" p="0.008"/>
  
  <!-- Optional: nebula wisps -->
  <one in="B" out="P" p="0.001"/>
  <markov steps="20">
    <rule in="PB" out="PP" p="0.3"/>
  </markov>
</sequence>
```

### Output Formats

**Option 1: Single Tileable Texture**
- Run MarkovJunior with toroidal boundary conditions
- Export as PNG
- Tile seamlessly on dome

**Option 2: Texture Atlas**
- Generate multiple variants
- Pack into atlas
- Blend between variants for variety

**Option 3: Runtime Generation**
- Generate textures at startup with random seed
- Each world has unique sky elements
- Could regenerate for weather/time changes

---

## File Structure (Anticipated)

**Existing files to MODIFY:**
```
crates/studio_core/src/deferred/
├── sky_dome.rs               # MODIFY: Add cloud texture config
├── sky_dome_node.rs          # MODIFY: Add cloud texture binding

assets/shaders/
└── sky_dome.wgsl             # MODIFY: Add cloud texture sampling + UV flow
```

**New files to CREATE:**
```
assets/textures/
├── clouds_placeholder.png    # Simple test pattern
└── generated/                # Output from MJ generation
    ├── mj_clouds_001.png
    ├── mj_moon_001.png
    ├── mj_moon_002.png
    └── mj_stars_001.png

MarkovJunior/models/
├── CloudTexture.xml          # Cloud generation model (NEW)
├── MoonTexture.xml           # Moon surface model (NEW)
├── MoonTextureAlt.xml        # Second moon style (NEW)
└── StarField.xml             # Star field model (NEW)

examples/
├── p32_markov_sky_test.rs    # Main test harness (screenshot capture)
├── p33_mj_cloud_gen.rs       # Cloud texture generation
├── p34_mj_moon_gen.rs        # Moon texture generation
└── p35_mj_stars_gen.rs       # Star field generation

scripts/
└── make_sky_video.sh         # FFMPEG frame-to-video script

screenshots/markov_sky/       # Captured frames (gitignored)
videos/                       # Generated videos (gitignored)
```

**Existing files to USE (no modification):**
```
crates/studio_core/src/markov_junior/
├── render.rs                 # render_2d(), save_png() - already exists
├── model.rs                  # Model::load_with_size() - already exists

examples/
└── p31_visual_fidelity_test.rs  # Pattern to follow for screenshot capture
```

---

## Benefits

### 1. Artistic Control
- Cloud shapes are designed, not purely random noise
- MarkovJunior allows rule-based patterns
- Easy to iterate on cloud style

### 2. Performance
- Single texture sample vs complex noise functions
- UV math is trivial
- Flow is per-vertex, not per-pixel

### 3. Aesthetic Consistency
- Clouds generated by same system as buildings
- Unified procedural aesthetic
- Seeded for reproducibility

### 4. Debugging Simplicity
- Cloud texture visible in isolation
- Flow vectors can be visualized
- Each layer is independent

### 5. Memory Efficiency
- Small tileable texture (256x256 or 512x512)
- No need for complex noise textures
- Reusable across scenes

---

## Potential Challenges

### 1. Tiling Artifacts
- **Risk:** Visible seams in cloud pattern
- **Mitigation:** Toroidal MarkovJunior generation, careful UV mapping

### 2. Flow Distortion at Poles
- **Risk:** UV pinching at dome top
- **Mitigation:** Use icosphere instead of UV sphere, or fade clouds near zenith

### 3. Moon Occlusion
- **Risk:** Moons should be behind clouds
- **Mitigation:** Proper depth/layer ordering, or alpha mask based on moon position

### 4. Cloud Variety
- **Risk:** Same clouds get repetitive
- **Mitigation:** Multiple texture variants, blend between them

---

## Related Techniques

### Flowmap-Based Animation
- Could use actual flowmap texture for non-uniform flow
- Vortices, turbulence patterns
- More complex but more natural

### Parallax Layers
- Multiple cloud layers at different depths
- Different flow speeds create depth illusion
- Popular in 2D games, works in 3D too

### Temporal Blending
- Cross-fade between cloud textures over time
- Gradual weather transitions
- Requires texture atlas or streaming

---

## Verification Commands Quick Reference

Every phase has a single command that proves it works:

| Phase | Verification Command | Expected Output |
|-------|---------------------|-----------------|
| 0 | `cargo run --example p32_markov_sky_test && ls screenshots/markov_sky/` | `frame_0001.png` exists |
| 1 | `cargo run --example p32_markov_sky_test` | Existing sky gradient visible (baseline) |
| 2 | `cargo run --example p32_markov_sky_test` | Placeholder pattern over sky gradient |
| 3 | `cargo run --example p33_mj_cloud_gen && open assets/textures/generated/mj_clouds_001.png` | Cloud PNG visible |
| 4 | `cargo run --example p32_markov_sky_test` | MJ clouds on dome (different from placeholder) |
| 5 | `cargo run --example p32_markov_sky_test -- --frames=60` | First/last frames differ |
| 6 | `./scripts/make_sky_video.sh && open videos/markov_sky_preview.mp4` | Video plays |
| 7 | Run with `--wind=1,0,0` then `--wind=0,0,1` | Different flow directions |
| 8 | `cargo run --example p34_mj_moon_gen` | Moon PNG exists |
| 9 | `cargo run --example p32_markov_sky_test` | Moon texture visible behind clouds |
| 10 | `--frames=120 --time-speed=10` then make video | Moon moves in video |
| 11 | Same as above | TWO moons moving |
| 12 | `cargo run --example p35_mj_stars_gen` then test | Stars behind clouds |
| 13 | `--time=0.25` vs `--time=0.6` | Cloud tint differs |

**Note:** All phases build on existing `sky_dome.wgsl`, `sky_dome_node.rs`, `sky_dome.rs`. We extend, not replace.

---

## Creative Ideas for Moon Textures (Future Reference)

### Classic Cratered
- Traditional moon look
- MarkovJunior crater growth

### Shattered/Crushed
- Main body with fracture lines
- Debris scattered around
- Crescent that was "broken"

### Disassembled
- Fragments floating in formation
- Held together by magic/gravity
- Gaps showing stars behind

### Ringed (Saturn-style)
- Central body
- Concentric debris rings
- Rings could be crushed/irregular

### Arcane/Magical
- Glowing runes on surface
- Energy patterns
- Otherworldly appearance

---

## References

- GDC Vault: The Last of Us - Sky Rendering (exact talk TBD)
- Flowmap techniques: https://catlikecoding.com/unity/tutorials/flow/texture-distortion/
- DMSkybox analysis: `docs/plans/dm_skybox_comparison.md`
- Our current sky plan: `docs/plans/visual_fidelity_improvements.md`
- MarkovJunior syntax: `MarkovJunior/syntax.md`
